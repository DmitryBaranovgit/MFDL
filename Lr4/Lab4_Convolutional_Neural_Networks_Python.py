# -*- coding: utf-8 -*-
"""Лабораторная_работа_#4-Сверточные_нейронные_сети.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j8VQNCd7lpruIfAEtz5FOlASdflLyTcD

# Лабораторная работа №4
Баранов Д.А. ИВТ 2.1

Используя датасет "Пассажиры автобуса", создайте нейронную сеть для решения задачи классификации пассажиров на входящих и выходящих.

Добейтесь точности работы модели выше 90% на проверочной выборке

### Загрузка данных
"""

# загрузка библиотек

# методы для отрисовки изображений
from PIL import Image

# Для отрисовки графиков
import matplotlib.pyplot as plt

# Для генерации случайных чисел
import random

# Библиотека работы с массивами
import numpy as np

# Для работы с файлами
import os

# импортируем модуль для загрузки данных
import gdown

# для разделения выборок
from sklearn.model_selection import train_test_split

# для создания сети
from tensorflow.keras.models import Sequential

# для создания слоев
from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Dropout, BatchNormalization

# для работы с изображениями
from tensorflow.keras.preprocessing import image

# оптимизатор
from tensorflow.keras.optimizers import Adam

# модуль для отсчета времени
import time

# загрузка датасета, укажем путь к базе в Google Drive, база в виде .zip-архива
# https://storage.yandexcloud.net/algorithmic-datasets/bus.zip
gdown.download('https://storage.yandexcloud.net/algorithmic-datasets/bus.zip', None, quiet=True)

# Распакуем архив в директорию 'content/bus'
!unzip -q "bus.zip" -d /content/
!unzip -q "busl.zip" -d /content/bus

# Папка с папками картинок, рассортированных по категориям
IMAGE_PATH = '/content/bus'

# Получение списка папок, находящемуся по адресу в скобках
os.listdir(IMAGE_PATH)

from google.colab import drive
drive.mount('/content/drive')

# Определение списка имен классов
CLASS_LIST = sorted(os.listdir(IMAGE_PATH))

# Определение количества классов
CLASS_COUNT = len(CLASS_LIST)

# Проверка результата
print(f'Количество классов: {CLASS_COUNT}, метки классов: {CLASS_LIST}')

# Получения списка файлов для каждого класса

for cls in CLASS_LIST:
    print(cls, ':', os.listdir(f'{IMAGE_PATH}/{cls}'))

"""Отобразим визуально для примера по одному изображению из каждого класса (при помощи функции `.imshow()` из модуля `matplotlib.pyplot`):"""

# Создание заготовки для изображений всех классов
fig, axs = plt.subplots(1, CLASS_COUNT, figsize=(10, 5))

# Для всех номеров классов:
for i in range(CLASS_COUNT):

    # Формирование пути к папке содержимого класса
    class_name = CLASS_LIST[i]
    if "Входящий" in class_name:
      class_name = class_name.replace("Входящий", "Входящий/")
    elif "Выходящий" in class_name:
      class_name = class_name.replace("Выходящий", "Выходящий/")

    car_path = f'{IMAGE_PATH}/{class_name}'

    # Выбор случайного фото из i-го класса
    img_path = car_path + random.choice(os.listdir(car_path))

    # Отображение фотографии (подробнее будет объяснено далее)
    axs[i].set_title(CLASS_LIST[i])
    axs[i].imshow(Image.open(img_path))
    axs[i].axis('off')

# Отрисовка всего полотна
plt.show()

data_files = []                           # Cписок путей к файлам картинок
data_labels = []                          # Список меток классов, соответствующих файлам

for class_label in range(CLASS_COUNT):    # Для всех классов по порядку номеров (их меток)
    class_name = CLASS_LIST[class_label]  # Выборка имени класса из списка имен
    class_path = os.path.join(IMAGE_PATH + class_name)  # Формирование полного пути к папке с изображениями класса
    if "Входящий" in class_name:
      class_name_modified = class_name.replace("Входящий", "Входящий/")
    elif "Выходящий" in class_name:
      class_name_modified = class_name.replace("Выходящий", "Выходящий/")
    else:
      class_name_modified = class_name

    class_path = os.path.join(IMAGE_PATH, class_name_modified)

    # Получаем список файлов в папке
    if os.path.isdir(class_path):
      class_files = os.listdir(class_path)
    else:
      class_path = os.path.dirname(class_path)
      class_files = [os.path.basename(class_name_modified)]

    print(f'Размер класса {class_name} составляет {len(class_files)} фото')

    # Добавление к общему списку всех файлов класса с добавлением родительского пути
    data_files += [os.path.join(class_path, file_name) for file_name in class_files]

    # Добавление к общему списку меток текущего класса - их ровно столько, сколько файлов в классе
    data_labels += [class_label] * len(class_files)

print()
print('Общий размер базы для обучения:', len(data_labels))

"""# 1. Загрузка и предобработка изображений"""

IMG_SIZE = 100 # PX
X = []
y = []

for img_path, label in zip(data_files, data_labels):
  try:
    img = image.load_img(img_path, target_size = (IMG_SIZE, IMG_SIZE))
    img_array = image.img_to_array(img) / 255.0 # Нормализация
    X.append(img_array)
    y.append(label)
  except Exception as e:
    print(f"Ошибка при обработке {img_path}: {e}")

X = np.array(X)
y = np.array(y)

print("Размер X:", X.shape)
print("Размер y:", y.shape)

"""# 2. Разделение на выборки"""

X_train, X_val, y_train, y_val = train_test_split(X, y, test_size = 0.2, random_state=42, stratify=y)
print("Обучающая выборка:", X_train.shape, y_train.shape)
print("Проверочная выборка:", X_val.shape, y_val.shape)

"""# 3. Построение модели CNN"""

model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(IMG_SIZE, IMG_SIZE, 3)),
    MaxPooling2D(2, 2),

    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),

    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D(2, 2),

    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

model.compile(optimizer=Adam(learning_rate=0.0001),
              loss = 'binary_crossentropy',
              metrics = ['accuracy'])

model.summary()

"""# 4. Обучение модели"""

start = time.time()

history = model.fit(
    X_train, y_train,
    epochs = 15,
    batch_size = 32,
    validation_data = (X_val, y_val)
)

end = time.time()
print(f"\n Время обучения: {round(end - start, 2)} сек.")

"""# 5. Визуализация и проверка точности"""

plt.plot(history.history['accuracy'], label = 'Обучающая точность')
plt.plot(history.history['val_accuracy'], label = 'Проверочная точность')
plt.title('Точность модели')
plt.xlabel('Эпоха')
plt.ylabel('Точность')
plt.legend()
plt.grid(True)
plt.show()

# Проверка точности
loss, accuracy = model.evaluate(X_val, y_val, verbose = 0)
print(f'\n Проверочная точность модели: {accuracy * 100:.2f}%')